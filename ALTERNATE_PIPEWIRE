Great question, Harish! Since you‚Äôve already been hands‚Äëon with the nRF5340 Audio DK and LE Audio broadcast (BAP) work, let me outline how you‚Äôd build a *Bluetooth‚Äëfocused audio service* on Linux that is **conceptually similar to PipeWire**, but purpose‚Äëbuilt for Bluetooth. I‚Äôll cover the architecture, the BlueZ D‚ÄëBus interfaces you must implement, LE Audio (BAP) vs. classic profiles (A2DP/HFP/HSP), real‚Äëtime/threading, codecs, and give you a minimal skeleton you can start from.

***

## 0) What ‚Äúsimilar to PipeWire‚Äù means (for Bluetooth)

PipeWire is a **low‚Äëlatency multimedia server** that builds a processing **graph of nodes** and talks to hardware via plugins; WirePlumber is the **session manager** loading PipeWire‚Äôs Bluetooth monitor plugins that watch BlueZ over D‚ÄëBus and create audio nodes for BT devices. Your custom service can adopt the same ideas‚Äî**a daemon + plugin architecture, a session/routing layer, and BlueZ D‚ÄëBus integration**‚Äîbut you‚Äôll only implement the Bluetooth parts you need (A2DP/HFP/LE Audio), without the full generality of PipeWire‚Äôs graph. [\[docs.pipewire.org\]](https://docs.pipewire.org/), [\[docs.pipewire.org\]](https://docs.pipewire.org/page_design.html), [\[pipewire.p...esktop.org\]](https://pipewire.pages.freedesktop.org/wireplumber/daemon/configuration/bluetooth.html)

***

## 1) High‚Äëlevel architecture (components)

**A. Bluetooth stack**: BlueZ (`bluetoothd`) exposes profiles and transports over **D‚ÄëBus**. You‚Äôll register as a **Media Endpoint** for A2DP/LE Audio, or hook telephony backends for HFP/HSP. [\[ukbaz.github.io\]](https://ukbaz.github.io/howto/python_gio_1.html), [\[github.com\]](https://github.com/RadiusNetworks/bluez/blob/master/doc/device-api.txt)

**B. Your service (daemon)**:

*   **D‚ÄëBus client** to `org.bluez` (**system bus**).
*   **Endpoint manager**: registers A2DP/HFP/BAP endpoints with BlueZ (via `org.bluez.Media1.RegisterEndpoint`).
*   **Transport manager**: listens for `MediaTransport1` state changes, **Acquires** the fd and moves PCM/frames in/out (L2CAP for AVDTP, ISO for LE Audio).
*   **Routing/mixing** (optional): a simple graph that routes device PCM streams to sinks/sources (ALSA, file, network, app callbacks).
*   **Codec layer**: SBC/AAC/etc for A2DP; LC3 for LE Audio (using **liblc3**).
*   **Policy/session**: similar to WirePlumber, but focused on Bluetooth roles (A2DP sink/source, HFP/HSP, BAP sink/source/broadcast). [\[github.com\]](https://github.com/pauloborges/bluez/blob/master/doc/media-api.txt), [\[man.archlinux.org\]](https://man.archlinux.org/man/extra/bluez-utils/org.bluez.MediaEndpoint.5.en), [\[man.archlinux.org\]](https://man.archlinux.org/man/extra/bluez-utils/org.bluez.MediaTransport.5.en), [\[pipewire.p...esktop.org\]](https://pipewire.pages.freedesktop.org/wireplumber/daemon/configuration/bluetooth.html)

**C. System integration**: `systemd` user service; **real‚Äëtime scheduling** (RTKit or RLIMIT\_RTPRIO) to keep latency down. [\[docs.pipewire.org\]](https://docs.pipewire.org/page_module_rt.html), [\[manpages.ubuntu.com\]](https://manpages.ubuntu.com/manpages/noble/man7/libpipewire-module-rt.7.html), [\[wiki.archlinux.org\]](https://wiki.archlinux.org/title/Realtime_process_management)

***

## 2) Decide your supported roles and enable BlueZ features

1.  **Classic Bluetooth (BR/EDR)**:
    *   **A2DP (music)**: implement endpoints for SBC/AAC/LDAC/aptX (note licensing for proprietary codecs). [\[wiki.archlinux.org\]](https://wiki.archlinux.org/title/Bluetooth_headset)
    *   **HFP/HSP (telephony)**: integrate a backend (**native**, **oFono**, or **hsphfpd**). mSBC (wideband 16 kHz) is optional. [\[pipewire.p...esktop.org\]](https://pipewire.pages.freedesktop.org/wireplumber/daemon/configuration/bluetooth.html), [\[wiki.archlinux.org\]](https://wiki.archlinux.org/title/Bluetooth_headset)

2.  **LE Audio (BAP)**:
    *   **Unicast (CIS)** and **Broadcast (BIS/Auracast)**; **LC3** codec; you acquire **ISO sockets** from BlueZ. Requires BlueZ experimental features. [\[bluez.org\]](https://www.bluez.org/le-audio-support/), [\[bluez.org\]](https://www.bluez.org/)

**BlueZ settings** (for BAP/ISO sockets): in `/etc/bluetooth/main.conf` set:

```ini
Experimental = true
KernelExperimental = 6fbaf188-05e0-496a-9885-d6ddfdb4e03e   # ISO socket UUID
```

Then test with `bluetoothctl endpoint.register ...` (PAC sink/source, BAP broadcast). [\[bluez.org\]](https://www.bluez.org/le-audio-support/), [\[man.archlinux.org\]](https://man.archlinux.org/man/extra/bluez-utils/bluetoothctl-endpoint.1.en)

> Why: BlueZ‚Äôs **Media API** lets your service present custom endpoints and handles transport setup. For **A2DP** you get an AVDTP/L2CAP fd; for **LE Audio** you get an **ISO** fd. You implement `MediaEndpoint1` methods like `SetConfiguration`/`SelectConfiguration` and operate the file descriptor returned by `MediaTransport1.Acquire`. [\[github.com\]](https://github.com/pauloborges/bluez/blob/master/doc/media-api.txt), [\[man.archlinux.org\]](https://man.archlinux.org/man/extra/bluez-utils/org.bluez.MediaEndpoint.5.en), [\[man.archlinux.org\]](https://man.archlinux.org/man/extra/bluez-utils/org.bluez.MediaTransport.5.en)

***

## 3) The core BlueZ D‚ÄëBus interfaces you need

*   **`org.bluez.Media1`** ‚Üí `RegisterEndpoint(object endpoint, dict properties)` to advertise your endpoint (UUID, codec, capabilities). Typical UUIDs:
    *   A2DP Sink: `0000110B-0000-1000-8000-00805F9B34FB`
    *   A2DP Source: `0000110A-0000-1000-8000-00805F9B34FB`
    *   BAP Unicast Sink/Source: `00002bc9-...` / `00002bcb-...`
    *   BAP Broadcast Sink/Source: `00001851-...` / `00001852-...`  
        (You‚Äôll see these in tools and docs.) [\[github.com\]](https://github.com/pauloborges/bluez/blob/master/doc/media-api.txt), [\[man.archlinux.org\]](https://man.archlinux.org/man/extra/bluez-utils/bluetoothctl-endpoint.1.en)

*   **`org.bluez.MediaEndpoint1`** ‚Üí implement on your own object path:
    *   `SelectConfiguration(array{byte} capabilities)` (A2DP) or `SelectProperties(dict caps)` (BAP)
    *   `SetConfiguration(object transport, dict properties)`
    *   `ClearConfiguration(object transport)` and `Release()`  
        These are the callbacks **BlueZ invokes** so you can choose codec parameters and prepare I/O. [\[man.archlinux.org\]](https://man.archlinux.org/man/extra/bluez-utils/org.bluez.MediaEndpoint.5.en), [\[manpages.debian.org\]](https://manpages.debian.org/testing/bluez/org.bluez.MediaEndpoint.5.en.html)

*   **`org.bluez.MediaTransport1`** on BlueZ‚Äôs transport object:
    *   `Acquire()` ‚Üí returns `(fd, read_mtu, write_mtu)`; you read/write encoded frames (AVDTP or ISO).
    *   For **broadcast sinks**, `Select()` / `Unselect()` control BIS sync state.
    *   Properties include `State` (`idle`, `pending`, `broadcasting`, `active`), `Configuration`, `Delay`, `Volume`. [\[man.archlinux.org\]](https://man.archlinux.org/man/extra/bluez-utils/org.bluez.MediaTransport.5.en)

***

## 4) Data‚Äëpath specifics (what you do with the fd)

**A2DP (AVDTP/L2CAP)**

*   On **sink**: decode incoming frames (SBC/AAC/LDAC) into PCM; route to ALSA or your processing graph.
*   On **source**: pull PCM from ALSA/mic/app, encode, write to fd with correct RTP/AVDTP framing. [\[deepwiki.com\]](https://deepwiki.com/bluez/bluez/4.2-a2dp)

**LE Audio (BAP/ISO)**

*   **Unicast**: configure LC3 (sample rate, frame duration 7.5/10 ms), QoS (maximum latency/delay). Your endpoint‚Äôs `SelectProperties` chooses these, `SetConfiguration` confirms.

*   Use **liblc3** for LC3 encode/decode (PipeWire uses it; you can too). You then pass LC3 frames to the **ISO** fd returned from `Acquire`. [\[bluez.org\]](https://www.bluez.org/)

*   **Broadcast (Auracast)**: as a **sink**, call `MediaTransport1.Select()` to sync to BIS(es), then `Acquire()`; as a **source**, create BAP broadcast endpoints and supply LC3 frames to broadcast ISO channels. (Auracast is still evolving in BlueZ; hardware support like **Intel AX210** helps.) [\[man.archlinux.org\]](https://man.archlinux.org/man/extra/bluez-utils/bluetoothctl-endpoint.1.en), [\[ak-experim...ogspot.com\]](https://ak-experiments.blogspot.com/2025/08/bluetooth-le-audio-on-raspberry-pi-with.html)

> Internally, BlueZ‚Äôs BAP profile uses **AF\_BLUETOOTH ISO sockets**; reading the source (`profiles/audio/bap.c`) is useful to understand states and QoS. [\[github.com\]](https://github.com/bluez/bluez/blob/master/profiles/audio/bap.c)

***

## 5) Minimal skeleton: register an endpoint and acquire a transport

Below is a **conceptual** Python sketch using `pydbus`/`gi.repository` APIs to show the shape of a **MediaEndpoint1**. (You can implement the same with GLib in C, `zbus` in Rust, or `sdbus-c++` in C++.)

```python
#!/usr/bin/env python3
# Minimal BlueZ MediaEndpoint1 example (A2DP sink) ‚Äì conceptual skeleton
# Interfaces and methods per org.bluez.MediaEndpoint1 / MediaTransport1 docs.
# See: org.bluez.MediaEndpoint(5), Media API docs.  (citations below)

from gi.repository import GLib
from pydbus import SystemBus

MEDIA_IFACE = "org.bluez.Media1"
ENDPOINT_IFACE = "org.bluez.MediaEndpoint1"
BLUEZ = "org.bluez"
ADAPTER = "/org/bluez/hci0"

class A2DPEndpoint(object):
    """
    Implement MediaEndpoint1. BlueZ calls these.
    """
    dbus = ENDPOINT_IFACE

    def SelectConfiguration(self, capabilities):
        # Return a byte array representing the selected codec configuration
        # For SBC, pick sample rate/channel-mode/subbands/bitpool etc.
        return bytes([0x00, 0x00, 0x35, 0x02])  # placeholder

    def SetConfiguration(self, transport, properties):
        # Store transport path and properties; then Acquire from MediaTransport1
        self.transport = transport
        # Acquire fd
        bus = SystemBus()
        t = bus.get(BLUEZ, transport)
        fd, rmtu, wmtu = t.Acquire()
        # TODO: start a thread that reads encoded frames from fd, decodes, routes to ALSA

    def ClearConfiguration(self, transport):
        # Clean up, close fd
        pass

    def Release(self):
        # Endpoint is being unregistered; tidy up
        pass

def main():
    bus = SystemBus()
    bluez = bus.get(BLUEZ, ADAPTER)
    # Export our endpoint object at a chosen path
    loop = GLib.MainLoop()
    endpoint_path = "/my/a2dp/endpoint"
    bus.register_object(endpoint_path, A2DPEndpoint(), None)

    # Register with org.bluez.Media1
    media = bus.get(BLUEZ, ADAPTER)
    props = {
        "UUID": "0000110B-0000-1000-8000-00805F9B34FB",  # A2DP Sink
        "Codec": 0x00,  # SBC
        "Capabilities": bytes([0x00, 0x00, 0x00])  # SBC caps blob (fill correctly)
    }
    media.RegisterEndpoint(endpoint_path, props)

    loop.run()

if __name__ == "__main__":
    main()
```

This follows the **Media API** shape: your service registers an endpoint, BlueZ calls `SelectConfiguration`/`SetConfiguration`, and you acquire the **transport fd** via `MediaTransport1.Acquire`. The same pattern applies to **LE Audio (BAP)** with different UUIDs and `SelectProperties` semantics. [\[github.com\]](https://github.com/pauloborges/bluez/blob/master/doc/media-api.txt), [\[man.archlinux.org\]](https://man.archlinux.org/man/extra/bluez-utils/org.bluez.MediaEndpoint.5.en), [\[man.archlinux.org\]](https://man.archlinux.org/man/extra/bluez-utils/org.bluez.MediaTransport.5.en)

> If you prefer C/C++: the GLib D‚ÄëBus guide and sdbus‚Äëc++ sample projects show how to wire to BlueZ in native code. [\[opencourse....cs.sfu.ca\]](https://opencoursehub.cs.sfu.ca/bfraser/grav-cms/cmpt433/links/files/2025-student-howtos/BlueZ_D-Bus_API_in_C.pdf), [\[github.com\]](https://github.com/gokulshiva77/bluez-sample-dbus)

***

## 6) Real‚Äëtime scheduling & systemd service

For low latency and fewer dropouts, give your daemon **real‚Äëtime priority**:

*   Add `realtime-privileges`/limits for your user (RLIMIT\_RTPRIO) or enable **RTKit** fallback. PipeWire‚Äôs `libpipewire-module-rt` docs explain the trade‚Äëoffs and config knobs; you can apply the same ideas to your service. [\[docs.pipewire.org\]](https://docs.pipewire.org/page_module_rt.html), [\[manpages.ubuntu.com\]](https://manpages.ubuntu.com/manpages/noble/man7/libpipewire-module-rt.7.html), [\[wiki.archlinux.org\]](https://wiki.archlinux.org/title/Realtime_process_management)

A minimal user service unit:

```ini
# ~/.config/systemd/user/bt-audio.service
[Unit]
Description=Harish BT Audio Service
After=bluetooth.target

[Service]
ExecStart=%h/bin/bt-audio-daemon
Restart=on-failure
# Allow RT priority if configured
LimitRTPRIO=88
LimitRTTIME=infinity

[Install]
WantedBy=default.target
```

> RTKit background and pros/cons (watchdog demotion, safety vs. pro‚Äëaudio needs): worth a read if you rely on it. [\[venam.net\]](https://venam.net/blog/unix/2025/03/24/rtkit.html)

***

## 7) Testing & developer workflow

*   **Discover endpoints and transports**: `bluetoothctl` has an **endpoint submenu** for BAP; you can quickly register sample endpoints to validate BlueZ‚Äôs side and states. [\[man.archlinux.org\]](https://man.archlinux.org/man/extra/bluez-utils/bluetoothctl-endpoint.1.en)
*   **Introspect BlueZ objects**: `busctl tree org.bluez` to view adapter/device/transport paths. [\[ukbaz.github.io\]](https://ukbaz.github.io/howto/python_gio_1.html)
*   **Profile‚Äëspecific checks**: For A2DP/HFP device behavior, ArchWiki‚Äôs headset page has pragmatic notes (codecs, hardware volume coupling). [\[wiki.archlinux.org\]](https://wiki.archlinux.org/title/Bluetooth_headset)
*   **LE Audio status & hardware**: Modern controllers (e.g., Intel AX210) help; community posts show experiments on Pi/AX210 with BlueZ/PipeWire. [\[ak-experim...ogspot.com\]](https://ak-experiments.blogspot.com/2025/08/bluetooth-le-audio-on-raspberry-pi-with.html)

***

## 8) If you target **LE Audio broadcast** (Auracast), aligned to your nRF5340 work

*   BlueZ exposes **BASS/PACS/ASCS** and BAP broadcast roles; for **sinks**, you typically:
    1.  Discover broadcast (scan/resolve BIS config),
    2.  `MediaTransport1.Select()` to begin broadcasting state,
    3.  `Acquire()` ISO fd and consume LC3 frames. [\[man.archlinux.org\]](https://man.archlinux.org/man/extra/bluez-utils/org.bluez.MediaTransport.5.en)

*   For **sources**, you register broadcast endpoints and stream into ISO BIS channels. This area is still maturing; demos and talks highlight ongoing work in BlueZ, PipeWire, and UX. [\[archive.fosdem.org\]](https://archive.fosdem.org/2023/schedule/event/bt_pipewire/attachments/slides/5419/export/events/attachments/bt_pipewire/slides/5419/FOSDEM23_Bluetooth_in_PipeWire_and_WirePlumber.pdf)

*   Since you use **nRF5340 Audio DK**, Nordic‚Äôs **BAP Broadcast Assistant**/Sink samples are handy to validate end‚Äëto‚Äëend flows (host+embedded). They show how assistants add broadcast IDs to a Scan Delegator and coordinate sinks. [\[docs.nordicsemi.com\]](https://docs.nordicsemi.com/bundle/ncs-latest/page/zephyr/samples/bluetooth/bap_broadcast_assistant/README.html), [\[docs.zephy...roject.org\]](https://docs.zephyrproject.org/latest/samples/bluetooth/bap_broadcast_assistant/README.html)

***

## 9) Reuse vs. re‚Äëimplement (pragmatic note)

If your goal is *production‚Äëgrade Bluetooth audio* for Linux clients, consider:

*   **Extending PipeWire/WirePlumber** with custom scripts/policies (roles, codecs, routing) rather than re‚Äëimplementing everything. WirePlumber exposes `monitor.bluez` properties to select roles/codecs/backends and is already wired to BlueZ D‚ÄëBus. [\[pipewire.p...esktop.org\]](https://pipewire.pages.freedesktop.org/wireplumber/daemon/configuration/bluetooth.html), [\[github.com\]](https://github.com/PipeWire/wireplumber/blob/master/src/config/wireplumber.conf.d.examples/bluetooth.conf)
*   If you still want a standalone daemon, keep the scope tight: endpoint & transport management + LC3/SBC encode/decode + a minimal router.

***

## 10) Common pitfalls

*   **Codec licensing**: AAC/aptX/LDAC have non‚Äëtrivial licensing; SBC and LC3 are the safest to start. PipeWire lists supported codecs and notes license status. [\[archive.fosdem.org\]](https://archive.fosdem.org/2023/schedule/event/bt_pipewire/attachments/slides/5419/export/events/attachments/bt_pipewire/slides/5419/FOSDEM23_Bluetooth_in_PipeWire_and_WirePlumber.pdf)
*   **BAP maturity & kernel**: LE Audio requires newer kernels, **ISO sockets**, and up‚Äëto‚Äëdate BlueZ; enabling **Experimental** and **KernelExperimental** is essential. Staying current (BlueZ 5.7x+) helps avoid ISO socket failures people saw with older versions. [\[bluez.org\]](https://www.bluez.org/le-audio-support/), [\[stackoverflow.com\]](https://stackoverflow.com/questions/78060505/bluetooth-le-audio-development-with-bluez-5-66)
*   **RT scheduling**: careless priorities can starve the system; follow vendor guidance (e.g., RHEL RT tuning) and keep priorities conservative. [\[docs.redhat.com\]](https://docs.redhat.com/en/documentation/red_hat_enterprise_linux_for_real_time/7/html/tuning_guide/setting_realtime_scheduler_priorities)

***

## 11) A concrete ‚ÄúMVP‚Äù plan (2‚Äì3 weeks)

1.  **D‚ÄëBus plumbing**: choose C (GLib), C++ (sdbus‚Äëc++), or Rust (zbus). Implement a **MediaEndpoint1** object and register A2DP **sink** first; acquire the **MediaTransport1** fd and decode **SBC** to ALSA playback. [\[github.com\]](https://github.com/pauloborges/bluez/blob/master/doc/media-api.txt), [\[man.archlinux.org\]](https://man.archlinux.org/man/extra/bluez-utils/org.bluez.MediaEndpoint.5.en)
2.  **Telemetry & state machine**: subscribe to BlueZ signals; log transport `State` transitions (`idle`‚Üí`pending`‚Üí`active`). [\[man.archlinux.org\]](https://man.archlinux.org/man/extra/bluez-utils/org.bluez.MediaTransport.5.en)
3.  **LE Audio unicast**: add **LC3** via `liblc3`; register BAP endpoints; handle `SelectProperties` and QoS; verify with a LE headset/controller. [\[bluez.org\]](https://www.bluez.org/)
4.  **Broadcast sink**: implement `Select()`/`Unselect()` and ISO acquisition; test against an **nRF5340 broadcast source** (your DK) and log BIS sync. [\[man.archlinux.org\]](https://man.archlinux.org/man/extra/bluez-utils/org.bluez.MediaTransport.5.en)
5.  **Session/policy**: simple routing rules (e.g., auto‚Äëroute first BT sink; pause on telephony); if needed, integrate a small scriptable layer. [\[pipewire.p...esktop.org\]](https://pipewire.pages.freedesktop.org/wireplumber/daemon/configuration/bluetooth.html)
6.  **RT + systemd**: add `LimitRTPRIO`, test under CPU stress; measure glitch rates. [\[wiki.archlinux.org\]](https://wiki.archlinux.org/title/Realtime_process_management), [\[docs.pipewire.org\]](https://docs.pipewire.org/page_module_rt.html)

***

## 12) Where to look next (deep dives & docs)

*   **BlueZ Media APIs** (A2DP/BAP endpoint & transport):  
    ‚Äì Manpages & docs for `MediaEndpoint1` and `MediaTransport1`. [\[man.archlinux.org\]](https://man.archlinux.org/man/extra/bluez-utils/org.bluez.MediaEndpoint.5.en), [\[manpages.debian.org\]](https://manpages.debian.org/testing/bluez/org.bluez.MediaEndpoint.5.en.html), [\[man.archlinux.org\]](https://man.archlinux.org/man/extra/bluez-utils/org.bluez.MediaTransport.5.en)
*   **PipeWire design & Bluetooth integration** (for reference architecture):  
    ‚Äì PipeWire docs (design/graph) & WirePlumber Bluetooth config. [\[docs.pipewire.org\]](https://docs.pipewire.org/page_design.html), [\[docs.pipewire.org\]](https://docs.pipewire.org/), [\[pipewire.p...esktop.org\]](https://pipewire.pages.freedesktop.org/wireplumber/daemon/configuration/bluetooth.html)
*   **LE Audio status & best practices**:  
    ‚Äì BlueZ‚Äôs LE Audio support posts and Collabora‚Äôs 2025 blog on implementing LE Audio & Auracast on Linux. [\[bluez.org\]](https://www.bluez.org/le-audio-support/), [\[collabora.com\]](https://www.collabora.com/news-and-blog/blog/2025/11/24/implementing-bluetooth-le-audio-and-auracast-on-linux-systems/)

***

## Quick follow‚Äëups for you

1.  **Which roles are you targeting first**: A2DP sink/source, HFP/HSP for calls, or **LE Audio (BAP) broadcast** with the nRF5340?
2.  **Language preference** for your daemon (C/C++/Rust/Python)?
3.  Do you want a **minimal router** (ALSA in/out) or a **small node graph** (closer to PipeWire) with pluggable DSP?

If you tell me those, I can tailor a starter repo structure (build files, D‚ÄëBus skeleton, endpoint registration, and a simple audio pipeline) aligned to your exact target.


***************************************END OF TEXT 1**************************************************

Got it‚Äîyou're looking for a **ready-to-run application/binary** on Linux that uses the **LC3 codec** for **LE Audio** with **BlueZ**. Below are two practical paths:

*   **Path A (fastest):** Use PipeWire‚Äôs built‚Äëin LE Audio support (LC3) as your ‚Äúbinary‚Äù and control BlueZ via D‚ÄëBus tools.
*   **Path B (custom):** Build a **standalone binary** that registers **LE Audio (BAP) endpoints** with BlueZ, acquires **ISO transports**, and encodes/decodes LC3 via **liblc3**.

I‚Äôll give you exact install/build commands and a minimal C program skeleton in Path B.

***

## Path A ‚Äî Use PipeWire as the LC3‚Äëenabled LE Audio server (no coding)

PipeWire (‚â• 0.3.59) can act as a **LE Audio BAP sink/source** with **LC3** when built/installed with LC3 enabled. BlueZ exposes the LE Audio controls and transports; PipeWire registers endpoints and does the LC3 work under the hood. This is the quickest way to get a working binary. [\[bluez.org\]](https://www.bluez.org/)

### 1) Install the pieces

**Debian/Ubuntu (22.10+):**

```bash
sudo apt update
sudo apt install bluez pipewire wireplumber libspa-0.2-bluetooth pipewire-pulse
```

> These packages deliver the PipeWire daemon + Bluetooth SPA plugin and WirePlumber (session manager). The Bluetooth plugin will talk to BlueZ over D‚ÄëBus and register BAP/A2DP/HFP endpoints. [\[docs.pipewire.org\]](https://docs.pipewire.org/), [\[pipewire.p...esktop.org\]](https://pipewire.pages.freedesktop.org/wireplumber/daemon/configuration/bluetooth.html)

**LC3 codec library (liblc3):**

*   Many distros ship it as `liblc3` / `liblc3-dev`. If not present, build from source:

```bash
# build liblc3
git clone https://github.com/google/liblc3.git
cd liblc3 && mkdir build && cd build
cmake .. && make
sudo make install
sudo ldconfig
```

PipeWire needs to be built with LC3 enabled on some distros; on others it is already enabled. If you build PipeWire yourself:

```bash
meson setup build -Dbluez5-codec-lc3=enabled
meson compile -C build
sudo meson install -C build
```

 [\[bluez.org\]](https://www.bluez.org/)

### 2) Enable LE Audio experimental features in BlueZ

Edit `/etc/bluetooth/main.conf`:

```ini
# LE Audio / ISO sockets require experimental flags
Experimental = true
KernelExperimental = 6fbaf188-05e0-496a-9885-d6ddfdb4e03e
```

Restart:

```bash
sudo systemctl restart bluetooth
```

 [\[bluez.org\]](https://www.bluez.org/le-audio-support/)

### 3) Start PipeWire & WirePlumber (as your user)

```bash
systemctl --user enable --now pipewire pipewire-pulse wireplumber
```

### 4) Verify endpoints and transport flows

Use `bluetoothctl`‚Äôs endpoint submenu to confirm BAP endpoints are present (Sink/Source or Broadcast), select CIS/BIS, and acquire transports:

```bash
bluetoothctl
# inside prompt:
endpoint.list
# for testing you can manually register too:
endpoint.register 00002bc9-0000-1000-8000-00805f9b34fb 0x06   # BAP Unicast Sink (LC3)
endpoint.register 00002bcb-0000-1000-8000-00805f9b34fb 0x06   # BAP Unicast Source (LC3)
# For broadcast:
endpoint.register 00001851-0000-1000-8000-00805f9b34fb 0x06   # BAP Broadcast Sink
endpoint.register 00001852-0000-1000-8000-00805f9b34fb 0x06   # BAP Broadcast Source
```

PipeWire will automatically create endpoints according to configured roles; manual registration is useful for debugging. [\[man.archlinux.org\]](https://man.archlinux.org/man/extra/bluez-utils/bluetoothctl-endpoint.1.en)

> Why this works: PipeWire‚Äôs Bluetooth plugin + WirePlumber load the BAP roles and LC3; BlueZ provides transports via **`MediaTransport1.Acquire()`** (returns ISO fd), and PipeWire streams LC3 frames. [\[pipewire.p...esktop.org\]](https://pipewire.pages.freedesktop.org/wireplumber/daemon/configuration/bluetooth.html), [\[man.archlinux.org\]](https://man.archlinux.org/man/extra/bluez-utils/org.bluez.MediaTransport.5.en)

***

## Path B ‚Äî Build your own LC3‚Äëloaded **binary** that uses BlueZ directly

If you want **your own executable** (e.g., `leaudiod`) that registers **LE Audio endpoints**, chooses **LC3** params, and reads/writes **ISO sockets**, follow this.

### 1) Prerequisites

*   **BlueZ** installed and running (`bluetoothd`), with **Experimental** and **KernelExperimental** set as above. [\[bluez.org\]](https://www.bluez.org/le-audio-support/)
*   **liblc3** installed (for LC3 encode/decode). [\[bluez.org\]](https://www.bluez.org/)
*   D‚ÄëBus bindings:
    *   C with GLib (`gio`/`gdbus`), or
    *   C++ with `sdbus-c++`, or
    *   Rust with `zbus`. For C++ samples, see `bluez-sample-dbus`. [\[opencourse....cs.sfu.ca\]](https://opencoursehub.cs.sfu.ca/bfraser/grav-cms/cmpt433/links/files/2025-student-howtos/BlueZ_D-Bus_API_in_C.pdf), [\[github.com\]](https://github.com/gokulshiva77/bluez-sample-dbus)

### 2) What your binary must implement

You will create a D‚ÄëBus object implementing **`org.bluez.MediaEndpoint1`** and register it via **`org.bluez.Media1.RegisterEndpoint`**.  
BlueZ will call your endpoint‚Äôs methods:

*   `SelectProperties(dict capabilities)` (**BAP unicast**) or `SelectConfiguration(array{byte})` (**A2DP**) ‚Üí you choose LC3 sampling rate (16/24/32/48 kHz), frame duration (7.5/10 ms), channel allocation, QoS, etc. [\[manpages.debian.org\]](https://manpages.debian.org/testing/bluez/org.bluez.MediaEndpoint.5.en.html)
*   `SetConfiguration(object transport, dict properties)` ‚Üí you **Acquire** the transport via **`MediaTransport1.Acquire()`** and get the ISO fd + MTUs. [\[man.archlinux.org\]](https://man.archlinux.org/man/extra/bluez-utils/org.bluez.MediaTransport.5.en)
*   Then loop: **read/write LC3 frames** on that fd (unicast CIS or broadcast BIS). Close and cleanup in `ClearConfiguration/Release`.  
    *Docs/manpages that define this flow:* **MediaEndpoint(5)** and **MediaTransport(5)**. [\[man.archlinux.org\]](https://man.archlinux.org/man/extra/bluez-utils/org.bluez.MediaEndpoint.5.en), [\[manpages.debian.org\]](https://manpages.debian.org/testing/bluez/org.bluez.MediaEndpoint.5.en.html), [\[man.archlinux.org\]](https://man.archlinux.org/man/extra/bluez-utils/org.bluez.MediaTransport.5.en)

### 3) Minimal C skeleton (conceptual)

> This is a compact **concept** showing the D‚ÄëBus shape and the **ISO fd** acquisition; flesh out error checks, LC3 encode/decode, and proper capability blobs as per BAP spec.

```c
// leaudiod.c ‚Äî Minimal LE Audio endpoint daemon using BlueZ + liblc3 (conceptual)
// Build: gcc leaudiod.c -o leaudiod `pkg-config --cflags --libs glib-2.0 gio-2.0` -llc3
// Requires: BlueZ with Experimental + ISO kernel experimental enabled, liblc3 installed.

#include <gio/gio.h>
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdint.h>

// D-Bus constants
#define BLUEZ_BUS          "org.bluez"
#define ADAPTER_PATH       "/org/bluez/hci0"
#define MEDIA_IFACE        "org.bluez.Media1"
#define ENDPOINT_IFACE     "org.bluez.MediaEndpoint1"
#define TRANSPORT_IFACE    "org.bluez.MediaTransport1"

// BAP Unicast Sink UUID (LC3)
#define BAP_SINK_UUID      "00002bc9-0000-1000-8000-00805f9b34fb"
// LC3 codec id for BAP (Assigned Number 0x06)
#define LC3_CODEC_ID       0x06

static GDBusConnection *bus = NULL;
static char *transport_path = NULL;
static int iso_fd = -1;

// Endpoint method handlers -----------------------------------------------------

// SelectProperties: choose LC3/QoS based on remote capabilities (simplified)
static gboolean handle_select_properties(GDBusConnection *conn, const char *sender,
    const char *obj_path, const char *iface, const char *method,
    GVariant *params, GDBusMethodInvocation *invocation, gpointer user_data)
{
    // params: (a{sv}) capabilities; return (ay ay a{sv})
    // In practice parse 'Capabilities','Metadata','Locations','QoS' from dict.
    // Here we return a minimal LC3 configuration (placeholder).
    const uint8_t lc3_caps[] = { /* LC3 config TLVs per BAP */ 0x02, 0x06 /* ... */ };
    const uint8_t metadata[] = { /* optional */ };

    GVariantBuilder builder;
    g_variant_builder_init(&builder, G_VARIANT_TYPE("a{sv}"));
    // QoS: Framing, PHY, Latency, Delay fields (fill properly)
    g_variant_builder_add(&builder, "{sv}", "Framing", g_variant_new_byte(0x00));
    g_variant_builder_add(&builder, "{sv}", "MaximumLatency", g_variant_new_uint16(20));
    // ...

    g_dbus_method_invocation_return_value(invocation,
        g_variant_new("(ayay@a{sv})",
            g_variant_new_fixed_array(G_VARIANT_TYPE_BYTE, lc3_caps, sizeof(lc3_caps), sizeof(uint8_t)),
            g_variant_new_fixed_array(G_VARIANT_TYPE_BYTE, metadata, sizeof(metadata), sizeof(uint8_t)),
            g_variant_builder_end(&builder)));

    return TRUE;
}

// SetConfiguration: store transport path, Acquire ISO fd and start I/O
static gboolean handle_set_configuration(GDBusConnection *conn, const char *sender,
    const char *obj_path, const char *iface, const char *method,
    GVariant *params, GDBusMethodInvocation *invocation, gpointer user_data)
{
    // params: (o a{sv}) -> transport object path, properties
    const char *tpath;
    GVariant *props;
    g_variant_get(params, "(&o@a{sv})", &tpath, &props);
    transport_path = g_strdup(tpath);

    // Acquire fd from MediaTransport1
    GError *err = NULL;
    GVariant *ret = g_dbus_connection_call_sync(conn, BLUEZ_BUS, transport_path,
        TRANSPORT_IFACE, "Acquire", NULL,
        G_VARIANT_TYPE("(hqq)"), G_DBUS_CALL_FLAGS_NONE, -1, NULL, &err);
    if (err) {
        g_dbus_method_invocation_return_dbus_error(invocation, "org.bluez.Error.Failed", err->message);
        g_error_free(err);
        return TRUE;
    }

    gint32 fd_idx; guint16 rmtu, wmtu;
    g_variant_get(ret, "(hqq)", &fd_idx, &rmtu, &wmtu);
    iso_fd = g_dbus_connection_dup_fd(conn, fd_idx, NULL);
    g_variant_unref(ret);

    // TODO: spawn threads:
    // - read LC3 frames from iso_fd (for sink) -> decode with liblc3 -> PCM -> ALSA
    // - or encode PCM to LC3 and write to iso_fd (for source)

    g_dbus_method_invocation_return_value(invocation, NULL);
    return TRUE;
}

static gboolean handle_clear_configuration(GDBusConnection *conn, const char *sender,
    const char *obj_path, const char *iface, const char *method,
    GVariant *params, GDBusMethodInvocation *invocation, gpointer user_data)
{
    if (iso_fd >= 0) { close(iso_fd); iso_fd = -1; }
    g_clear_pointer(&transport_path, g_free);
    g_dbus_method_invocation_return_value(invocation, NULL);
    return TRUE;
}

static gboolean handle_release(GDBusConnection *conn, const char *sender,
    const char *obj_path, const char *iface, const char *method,
    GVariant *params, GDBusMethodInvocation *invocation, gpointer user_data)
{
    if (iso_fd >= 0) { close(iso_fd); iso_fd = -1; }
    g_dbus_method_invocation_return_value(invocation, NULL);
    return TRUE;
}

// Register endpoint with org.bluez.Media1 -------------------------------------

static void register_endpoint()
{
    // Export our endpoint object implementing org.bluez.MediaEndpoint1
    static const GDBusInterfaceVTable vtable = {
        .method_call =  {
            if (!g_strcmp0(method, "SelectProperties"))
                handle_select_properties(c, sender, obj, iface, method, params, inv, u);
            else if (!g_strcmp0(method, "SetConfiguration"))
                handle_set_configuration(c, sender, obj, iface, method, params, inv, u);
            else if (!g_strcmp0(method, "ClearConfiguration"))
                handle_clear_configuration(c, sender, obj, iface, method, params, inv, u);
            else if (!g_strcmp0(method, "Release"))
                handle_release(c, sender, obj, iface, method, params, inv, u);
        }
    };

    const char *endpoint_path = "/leaudio/endpoint0";
    GError *err = NULL;
    guint reg_id = g_dbus_connection_register_object(bus, endpoint_path,
        g_dbus_node_info_new_for_xml(
            "<node><interface name='org.bluez.MediaEndpoint1'>"
            "<method name='SelectProperties'><arg type='a{sv}' direction='in'/>"
            "<arg type='ay' direction='out'/>"
            "<arg type='ay' direction='out'/>"
            "<arg type='a{sv}' direction='out'/></method>"
            "<method name='SetConfiguration'><arg type='o' direction='in'/>"
            "<arg type='a{sv}' direction='in'/></method>"
            "<method name='ClearConfiguration'><arg type='o' direction='in'/></method>"
            "<method name='Release'/></interface></node>"
        , NULL)->interfaces[0], &vtable, NULL, NULL, &err);
    if (err) { g_error("Endpoint export failed: %s", err->message); }

    // Call RegisterEndpoint on org.bluez.Media1
    GVariantBuilder caps_builder; // LC3 PAC caps TLV must be filled per BAP
    g_variant_builder_init(&caps_builder, G_VARIANT_TYPE("ay"));
    // TODO: push real LC3 capability bytes
    g_variant_builder_add(&caps_builder, "y", (guchar)0x06);

    GVariantBuilder props;
    g_variant_builder_init(&props, G_VARIANT_TYPE("a{sv}"));
    g_variant_builder_add(&props, "{sv}", "UUID", g_variant_new_string(BAP_SINK_UUID));
    g_variant_builder_add(&props, "{sv}", "Codec", g_variant_new_byte(LC3_CODEC_ID));
    g_variant_builder_add(&props, "{sv}", "Capabilities", g_variant_builder_end(&caps_builder));

    GError *err2 = NULL;
    g_dbus_connection_call_sync(bus, BLUEZ_BUS, ADAPTER_PATH, MEDIA_IFACE, "RegisterEndpoint",
        g_variant_new("(oa{sv})", endpoint_path, g_variant_builder_end(&props)),
        NULL, G_DBUS_CALL_FLAGS_NONE, -1, NULL, &err2);
    if (err2) { g_error("RegisterEndpoint failed: %s", err2->message); }
}

int main()
{
    GError *err = NULL;
    bus = g_bus_get_sync(G_BUS_TYPE_SYSTEM, NULL, &err);
    if (err) { g_error("Failed to connect to system bus: %s", err->message); }

    register_endpoint();

    // Main loop
    GMainLoop *loop = g_main_loop_new(NULL, FALSE);
    g_main_loop_run(loop);
    return 0;
}
```

**Key references** for the methods and transport acquisition above: the **MediaEndpoint** and **MediaTransport** manpages and BlueZ Media API docs. [\[man.archlinux.org\]](https://man.archlinux.org/man/extra/bluez-utils/org.bluez.MediaEndpoint.5.en), [\[manpages.debian.org\]](https://manpages.debian.org/testing/bluez/org.bluez.MediaEndpoint.5.en.html), [\[github.com\]](https://github.com/pauloborges/bluez/blob/master/doc/media-api.txt)

### 4) Build & run

```bash
gcc leaudiod.c -o leaudiod `pkg-config --cflags --libs glib-2.0 gio-2.0` -llc3
sudo ./leaudiod
```

### 5) Drive it from `bluetoothctl`

*   Pair/connect your LE Audio device, then let BlueZ negotiate the PAC/ASEs.
*   Your endpoint‚Äôs `SelectProperties`/`SetConfiguration` will be invoked; `MediaTransport1` gives you the **ISO fd**.
*   For broadcast, call `MediaTransport1.Select()` to sync to BIS(es). [\[man.archlinux.org\]](https://man.archlinux.org/man/extra/bluez-utils/org.bluez.MediaTransport.5.en)

***

## Real‚Äëtime scheduling (avoid glitches)

Give your binary real‚Äëtime priority (safe bounds) so LC3 encode/decode doesn‚Äôt underrun:

```ini
# ~/.config/systemd/user/leaudiod.service
[Unit]
Description=LE Audio LC3 Endpoint Daemon
After=bluetooth.target

[Service]
ExecStart=%h/bin/leaudiod
Restart=on-failure
LimitRTPRIO=80
LimitRTTIME=infinity

[Install]
WantedBy=default.target
```

Then:

```bash
systemctl --user enable --now leaudiod
```

See PipeWire‚Äôs RT module docs and Arch‚Äôs realtime guide for rationale and safe ranges. [\[docs.pipewire.org\]](https://docs.pipewire.org/page_module_rt.html), [\[wiki.archlinux.org\]](https://wiki.archlinux.org/title/Realtime_process_management)

***

## Notes & caveats

*   **Keep BlueZ current**: LE Audio is evolving; older BlueZ versions (e.g., 5.66) had ISO socket hiccups‚Äînewer (5.7x+) works better. If something fails, upgrade BlueZ or use the official `bluez` snap track matching your base. [\[stackoverflow.com\]](https://stackoverflow.com/questions/78060505/bluetooth-le-audio-development-with-bluez-5-66), [\[ubuntu.com\]](https://ubuntu.com/core/docs/bluez/reference/dbus-api)
*   **Hardware**: LE Audio works best with controllers like **Intel AX210**; some chipsets lag in ISO support. Community testing confirms AX210‚Äôs suitability. [\[ak-experim...ogspot.com\]](https://ak-experiments.blogspot.com/2025/08/bluetooth-le-audio-on-raspberry-pi-with.html)
*   **Exact LC3 capability blobs/QoS**: You must format capabilities per BAP spec; use the **MediaEndpoint SelectProperties** schema and QoS keys described in the manpage. [\[manpages.debian.org\]](https://manpages.debian.org/testing/bluez/org.bluez.MediaEndpoint.5.en.html)

***

## Which route do you prefer?

*   If you want **a ready binary today**, go with **Path A (PipeWire)**‚Äîit‚Äôs production‚Äëgrade and already LC3‚Äëcapable.
*   If you need a **custom binary you control**, start from the skeleton in **Path B**; I can turn that into a full repo (CMake, proper LC3 PAC/QoS, ALSA integration, unicast/broadcast modes, unit tests).

Tell me:

1.  **Unicast or Broadcast** first?
2.  **Sink, Source, or both**?
3.  **C/C++** preference (GLib or sdbus‚Äëc++)?

I‚Äôll generate a complete starter project for you with the right LC3 PAC/QoS blobs and a simple PCM‚ÜíLC3‚ÜíISO pipeline aligned to your device.
*****************************************END OF TEXT 2********************************************

You **create this folder structure *anywhere on your Linux machine*** ‚Äî it is your **project workspace**.  
Most developers place it in:

### ‚úÖ Recommended locations

*   **Your home directory**
        ~/leaudio/
*   or inside a **development folder**
        ~/workspace/leaudio/
        ~/projects/leaudio/

### ‚ùó DO NOT put it inside:

*   `/usr/`
*   `/etc/`
*   `/opt/` (unless you intentionally want a system‚Äëwide installation)
*   `/home/root` or anything requiring root permissions.

This is your own application, so keep it inside your **user‚Äëwritable directory**.

***

# üîß Step‚Äëby‚ÄëStep: Create the directory and files

Open a terminal and run:

```bash
cd ~
mkdir -p leaudio/src
mkdir -p leaudio/include
touch leaudio/CMakeLists.txt
touch leaudio/README.md
touch leaudio/src/leaudiod.c
touch leaudio/src/lc3_pipe.c
touch leaudio/include/lc3_pipe.h
```

Now your structure looks like:

    leaudio/
    ‚îú‚îÄ src/
    ‚îÇ  ‚îú‚îÄ leaudiod.c
    ‚îÇ  ‚îî‚îÄ lc3_pipe.c
    ‚îú‚îÄ include/
    ‚îÇ  ‚îî‚îÄ lc3_pipe.h
    ‚îú‚îÄ CMakeLists.txt
    ‚îî‚îÄ README.md

***

# üìå Where you'll work from now on

You will always:

```bash
cd ~/leaudio
```

and edit files inside this folder.

When you are ready to build:

```bash
cd ~/leaudio
mkdir build
cd build
cmake ..
make
```

After building, run:

```bash
sudo ./leaudiod
```

***

# üìù Why create this folder like this?

This is a **standard C/C++ project layout** using **CMake**, and you will be:

‚úî Writing your application code (`leaudiod.c`)  
‚úî Adding LC3 encode/decode helpers (`lc3_pipe.c`)  
‚úî Exposing their declarations (`lc3_pipe.h`)  
‚úî Building everything with CMake (`CMakeLists.txt`)

So this project folder is simply your **development workspace**.

You can delete, move, zip, or git‚Äëpush this folder any time.

***

# üÜò Want me to generate all the file contents too?

I can give you **working** versions of:

*   `CMakeLists.txt`
*   `leaudiod.c`
*   `lc3_pipe.c`
*   `lc3_pipe.h`
*   `README.md`

so you can copy/paste them directly.

Would you like:

### üîπ A minimal LC3‚ÄëLE Audio **sink** only

(PCM playback ‚Üí LC3 decode ‚Üí LE Audio)

or

### üîπ A full **sink + source** implementation?
****************************************END OF TEXT 3*************************************

it is not created in bluez5.83 directory right?


No ‚Äî **you should NOT create the `leaudio/` project inside the BlueZ 5.83 source directory**.

### ‚úÖ Correct Location

Create your **leaudio application in your own user workspace**, for example:

    ~/leaudio/

### ‚ùå NOT inside BlueZ source tree

Do **NOT** put it in:

    bluez-5.83/
    bluez-5.83/src/
    bluez-5.83/profiles/
    bluez-5.83/plugins/

### Why?

Because:

1.  **BlueZ is the Bluetooth system stack**, not your application.
2.  You are writing a **separate user‚Äëspace D‚ÄëBus client** that talks to BlueZ.
3.  Your application uses **BlueZ D-Bus interfaces** such as `MediaEndpoint1` and `MediaTransport1`, but it does not need to modify or rebuild BlueZ.
4.  Keeping it outside BlueZ avoids breaking BlueZ and keeps your application clean.

***

# ‚úîÔ∏è Recommended Setup

Create the project **in your home directory**:

```bash
cd ~
mkdir -p leaudio/src
mkdir -p leaudio/include
touch leaudio/CMakeLists.txt
touch leaudio/README.md
touch leaudio/src/leaudiod.c
touch leaudio/src/lc3_pipe.c
touch leaudio/include/lc3_pipe.h
```

This creates:

    ~/leaudio/
    ‚îú‚îÄ src/
    ‚îÇ  ‚îú‚îÄ leaudiod.c
    ‚îÇ  ‚îî‚îÄ lc3_pipe.c
    ‚îú‚îÄ include/
    ‚îÇ  ‚îî‚îÄ lc3_pipe.h
    ‚îú‚îÄ CMakeLists.txt
    ‚îî‚îÄ README.md

***

# ‚úîÔ∏è How your application interacts with BlueZ

BlueZ 5.83 runs as its own system daemon:

    /usr/libexec/bluetooth/bluetoothd

Your `leaudiod` binary does NOT run **inside** bluez-5.83.  
Instead, your app communicates with BlueZ through **system D‚ÄëBus**:

*   Register endpoints ‚Üí `org.bluez.Media1.RegisterEndpoint`
*   Handle codec config ‚Üí `org.bluez.MediaEndpoint1` methods
*   Acquire ISO transport ‚Üí `org.bluez.MediaTransport1.Acquire`

BlueZ remains an independent installed system component.

***

# ‚úîÔ∏è Build your application separately

From your project folder:

```bash
cd ~/leaudio
mkdir build
cd build
cmake ..
make
```

Then run your LE Audio daemon:

```bash
sudo ./leaudiod
```

***

# üîç Clarification

If you already have BlueZ 5.83 built from source (with `./configure && make && sudo make install`), that‚Äôs fine ‚Äî but your **application stays separate**, like any other Linux program that uses a system library.

***

# üéØ Summary

| Question                                                                | Answer                                                       |
| ----------------------------------------------------------------------- | ------------------------------------------------------------ |
| Should I create the `leaudio/` project inside the BlueZ 5.83 directory? | **NO**                                                       |
| Where do I create it?                                                   | In your home directory or any workspace (e.g., `~/leaudio/`) |
| Does my app modify BlueZ?                                               | **No, it only talks to BlueZ over D‚ÄëBus**                    |
| Do I need to rebuild BlueZ 5.83 for my app?                             | Only if you need updated LE Audio experimental features      |

***

# üëã Want me to generate *all complete files* for your project now?

I can give you:

*   Full **CMakeLists.txt**
*   Fully working `leaudiod.c`
*   LC3 encoder/decoder helpers
*   README with compile + run instructions
*   Optional: **source mode** (LC3 encode), **broadcast sink/source** mode.

Just tell me:

### Do you want:

1.  **Unicast Sink only**
2.  **Unicast Sink + Source**
3.  **Broadcast (Auracast) Sink**
4.  **All of the above**?

I‚Äôll prepare the entire project for you.

***************************************END OF TEXT 4*************************************************

Does it effect my system pipewire

Short answer: **NO ‚Äî your custom LE Audio application will *not* affect your system's PipeWire installation**, *as long as you run it as a separate user‚Äëspace program*, which is exactly what we are doing.

Let me explain clearly.

***

# ‚úÖ Why your LE Audio app does NOT affect PipeWire

### 1. **Your app talks directly to BlueZ over D‚ÄëBus**

Your `leaudiod` binary:

*   registers **MediaEndpoint1**
*   acquires **MediaTransport1** ISO sockets
*   decodes/encodes LC3
*   sends/receives audio via ALSA

This communication path is:

    leaudiod  ‚Üí  BlueZ (bluetoothd)  ‚Üí kernel (BT stack & ISO sockets)

PipeWire is **not** in this path.

‚û°Ô∏è Therefore, **PipeWire is untouched.**

***

# ‚ö†Ô∏è When can PipeWire and your app both use Bluetooth?

### 2. BlueZ allows **only one Bluetooth audio manager per user session**

Normally:

*   PipeWire‚Äôs Bluetooth plugin (via WirePlumber) registers the **A2DP/HFP/BAP** endpoints automatically.    [\[pipewire.p...esktop.org\]](https://pipewire.pages.freedesktop.org/wireplumber/daemon/configuration/bluetooth.html)

*   Your custom app also wants to register **its own endpoints** using BlueZ.

BlueZ will **not allow two clients to own the same audio roles** (like A2DP Sink, BAP Sink, etc.).

### That means:

‚úî Your app does NOT break PipeWire  
‚ùå But **PipeWire will take over Bluetooth audio**, unless you disable PipeWire Bluetooth.

***

# üüß So you must decide **who manages Bluetooth audio?**

## Option A ‚Äî **Use PipeWire normally (safe, default)**

Your app runs separately but **cannot** control LE Audio endpoints because PipeWire already registered them.  
(BlueZ will ignore or reject your endpoints.)

PipeWire remains responsible for Bluetooth audio, including LE Audio.  
You can still experiment by using PipeWire as your LE Audio server.    [\[bluez.org\]](https://www.bluez.org/)

## Option B ‚Äî **Disable PipeWire Bluetooth**, allow YOUR app to control LE Audio

To test your custom `leaudiod`, you must prevent PipeWire from grabbing BlueZ‚Äôs audio roles.

Disable WirePlumber‚Äôs BlueZ monitor:

```bash
mkdir -p ~/.config/wireplumber/wireplumber.conf.d
cat <<EOF > ~/.config/wireplumber/wireplumber.conf.d/99-disable-bluez.conf
monitor.bluez.enabled = false
EOF
```

Then restart:

```bash
systemctl --user restart wireplumber
systemctl --user restart pipewire pipewire-pulse
```

This frees all Bluetooth audio from PipeWire.

‚û°Ô∏è Your `leaudiod` app can now register LE Audio endpoints and acquire ISO transports.

***

# üü© Absolutely SAFE: You are **not modifying or uninstalling PipeWire**

You are only **disabling Bluetooth functionality** temporarily when testing your app.

PipeWire still works for:

*   system audio
*   media playback
*   microphone
*   desktop apps

Only **Bluetooth audio routing** is disabled.

Whenever you want PipeWire Bluetooth back:

```bash
rm ~/.config/wireplumber/wireplumber.conf.d/99-disable-bluez.conf
systemctl --user restart wireplumber
```

Now PipeWire handles Bluetooth audio again.

***

# üü¶ Summary

| Action                                             | Does it affect PipeWire?                               |
| -------------------------------------------------- | ------------------------------------------------------ |
| Creating `leaudiod` project                        | ‚ùå No                                                   |
| Building your app                                  | ‚ùå No                                                   |
| Running your app (with PipeWire Bluetooth enabled) | ‚ùå No, but BlueZ will ignore your endpoints             |
| Disabling PipeWire‚Äôs Bluetooth monitor             | ‚ö†Ô∏è Yes, but only Bluetooth audio, not the whole system |
| Returning settings to normal                       | ‚úîÔ∏è Restores full PipeWire functionality                |

***

# üü£ My recommendation for development

1.  **Keep PipeWire installed.**
2.  Disable only the Bluetooth part while testing your custom LE Audio daemon.
3.  Re‚Äëenable it anytime.

This gives you a safe, controlled environment.

***

# If you want, I can guide you through:

‚úî How to disable PipeWire Bluetooth safely  
‚úî How to verify BlueZ endpoint registration  
‚úî How to compare PipeWire LE Audio vs your custom LE Audio  
‚úî How to install PipeWire with LC3 support if needed  
‚úî How to test with your **nRF5340 Audio DK**

Just tell me!


******************************************END OF TEXT 5*************************************

My recommendation for development

Keep PipeWire installed.
Disable only the Bluetooth part while testing your custom LE Audio daemon.
Re‚Äëenable it anytime. how to do it give me step by step details


Below is the **correct, safe, step‚Äëby‚Äëstep procedure** to:

1.  **Keep PipeWire installed**
2.  **Disable only Bluetooth-related PipeWire/WirePlumber components** (so your custom LE Audio daemon can control BlueZ)
3.  **Re‚Äëenable PipeWire Bluetooth later** whenever you want

This method is 100% reversible and does **NOT** affect normal (non‚ÄëBluetooth) audio on your system.

***

# ‚úÖ **Part A ‚Äî Disable ONLY Bluetooth part of PipeWire (Safe for development)**

PipeWire uses **WirePlumber** to load the **BlueZ monitor plugin**, which automatically registers Bluetooth audio roles (A2DP, HFP, BAP).  
You must **disable that monitor**, otherwise PipeWire will ‚Äúown‚Äù Bluetooth audio and BlueZ will reject your app‚Äôs endpoints.

### üìç Step 1 ‚Äî Create WirePlumber override directory

```bash
mkdir -p ~/.config/wireplumber/wireplumber.conf.d
```

WirePlumber reads user configs from this directory and overrides its defaults.

***

### üìç Step 2 ‚Äî Disable BlueZ monitor (Bluetooth) for your user session

Create a file:

```bash
nano ~/.config/wireplumber/wireplumber.conf.d/99-disable-bluez.conf
```

Add **exactly** this:

```ini
# Disable PipeWire/WirePlumber Bluetooth integration for development
monitor.bluez.enabled = false
```

Save and exit (Ctrl+O, Enter, Ctrl+X).

***

### üìç Step 3 ‚Äî Restart WirePlumber + PipeWire

```bash
systemctl --user restart wireplumber
systemctl --user restart pipewire pipewire-pulse
```

### ‚úîÔ∏è After restart:

*   PipeWire **will NOT** register any Bluetooth endpoints
*   BlueZ becomes **free** to accept your application‚Äôs LC3 / LE Audio endpoints
*   Your app can now call `Media1.RegisterEndpoint` successfully
*   Your system audio (local playback, microphones) **still works normally**

***

### üéØ Verification

Run:

```bash
bluetoothctl
endpoint.list
```

If PipeWire Bluetooth is disabled:

*   You will **NOT** see PipeWire/WirePlumber endpoints
*   You **WILL** see endpoints only from your program (once your program runs)

This means the setup is correct.

***

# üü¶ **Part B ‚Äî Run your custom LE Audio daemon (`leaudiod`)**

Now that PipeWire is not interfering with Bluetooth audio:

```bash
sudo ./leaudiod
```

Your program should now:

*   Register LC3/BAP endpoint with `RegisterEndpoint`
*   Be allowed to receive `SetConfiguration` from BlueZ
*   Acquire ISO transport via `MediaTransport1.Acquire`
*   Start LC3 decode/encode without PipeWire blocking it

This is because BlueZ is no longer being managed by PipeWire‚Äôs Bluetooth monitor.

***

# üü© **Part C ‚Äî Re‚Äëenable PipeWire Bluetooth anytime (return system to normal)**

When you finish development/testing and want PipeWire Bluetooth back, do this:

### üìç Step 1 ‚Äî Delete the override file

```bash
rm ~/.config/wireplumber/wireplumber.conf.d/99-disable-bluez.conf
```

### üìç Step 2 ‚Äî Restart services

```bash
systemctl --user restart wireplumber
systemctl --user restart pipewire pipewire-pulse
```

### ‚úîÔ∏è After restart:

*   PipeWire Bluetooth is fully restored
*   A2DP/HFP/BAP handled again by PipeWire & WirePlumber
*   Your system behaves exactly like before
*   Your custom app will **not** be allowed to override these endpoints (expected)

***

# üüß **Part D ‚Äî Optional: Double-check settings**

### Check if PipeWire has taken back Bluetooth:

```bash
bluetoothctl
endpoint.list
```

PipeWire‚Äëregistered endpoints (A2DP sink/source, BAP sink/source etc.) will appear again.

***

# üü£ **Summary**

| Action                               | Affects PipeWire?              | Bluetooth?                                  |
| ------------------------------------ | ------------------------------ | ------------------------------------------- |
| Disable BlueZ monitor in WirePlumber | ‚ùå No (PipeWire core untouched) | ‚úîÔ∏è Yes (Bluetooth freed for your app)       |
| Delete override file                 | ‚ùå No                           | ‚úîÔ∏è Restores normal PipeWire Bluetooth       |
| Running your own `leaudiod`          | ‚ùå No                           | ‚úîÔ∏è Takes control of Bluetooth from PipeWire |

***

# üü¢ **You are safe**

Following the steps above keeps the system completely stable.  
You are only toggling **one plugin** in WirePlumber, not touching PipeWire itself.

***

# If you want, I can also generate:

‚úî A ready‚Äëmade script: `disable_pipewire_bt.sh` + `enable_pipewire_bt.sh`  
‚úî A full LE Audio unicast sink + source project  
‚úî A ready‚Äëto-compile GitHub‚Äëstyle repository

Would you like automated scripts or full project code next?




